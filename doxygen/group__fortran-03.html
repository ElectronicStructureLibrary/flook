<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>flook: Fortran-03</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">flook
   &#160;<span id="projectnumber">0.7</span>
   </div>
   <div id="projectbrief">FORTRAN wrappers for calling LUA</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Modules</a> &#124;
<a href="#nested-classes">Data Types</a> &#124;
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle">
<div class="title">Fortran-03</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <b>flook</b> interface for fortran-2003 standard. This realizes object oriented programming in the model and abstracts routines <em>onto</em> the objects themselves such that operations are intrinsic to each type.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Modules</h2></td></tr>
<tr class="memitem:namespaceflook"><td class="memItemLeft" align="right" valign="top">module &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceflook.html">flook</a></td></tr>
<tr class="memdesc:namespaceflook"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accomodates a generic interface for communicating data between an embedded LUA environment and FORTRAN. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Types</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structflook_1_1luatbl.html">flook::luatbl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle for interacting with LUA tables.  <a href="structflook_1_1luatbl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceflook_1_1len.html">flook::len</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of a table.  <a href="interfaceflook_1_1len.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:ga6d7fddb972f9de080fc37a94fc23de13"><td class="memItemLeft" align="right" valign="top">generic, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fortran-03.html#ga6d7fddb972f9de080fc37a94fc23de13">flook::luastate::init</a> =&gt; state_init_, state_init_ptr_</td></tr>
<tr class="memdesc:ga6d7fddb972f9de080fc37a94fc23de13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization of a new LUA environment. Can be instantiated either by no arguments (creates a new LUA environment) or by passing a C-pointer which extracts the current LUA environment from an already running instance.  <a href="#ga6d7fddb972f9de080fc37a94fc23de13">More...</a><br /></td></tr>
<tr class="separator:ga6d7fddb972f9de080fc37a94fc23de13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9552df4f66be93a29ba1794435af3c6c"><td class="memItemLeft" align="right" valign="top">generic, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fortran-03.html#ga9552df4f66be93a29ba1794435af3c6c">flook::luastate::close</a> =&gt; state_close_</td></tr>
<tr class="memdesc:ga9552df4f66be93a29ba1794435af3c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the current LUA environment.  <a href="#ga9552df4f66be93a29ba1794435af3c6c">More...</a><br /></td></tr>
<tr class="separator:ga9552df4f66be93a29ba1794435af3c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0172f41cd5c88b3aa8a298ebf40faa30"><td class="memItemLeft" align="right" valign="top">generic, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fortran-03.html#ga0172f41cd5c88b3aa8a298ebf40faa30">flook::luastate::register</a> =&gt; reg_func_</td></tr>
<tr class="memdesc:ga0172f41cd5c88b3aa8a298ebf40faa30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register FORTRAN functions to be called directly from LUA.  <a href="#ga0172f41cd5c88b3aa8a298ebf40faa30">More...</a><br /></td></tr>
<tr class="separator:ga0172f41cd5c88b3aa8a298ebf40faa30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9043137552c934a0ced08b21d08195f"><td class="memItemLeft" align="right" valign="top">generic, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fortran-03.html#gaa9043137552c934a0ced08b21d08195f">flook::luastate::run</a> =&gt; state_run_</td></tr>
<tr class="memdesc:gaa9043137552c934a0ced08b21d08195f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs either code by <code>character(len=*)</code> or by reading a file.  <a href="#gaa9043137552c934a0ced08b21d08195f">More...</a><br /></td></tr>
<tr class="separator:gaa9043137552c934a0ced08b21d08195f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4855936b441ec2242b32cf6e32677fde"><td class="memItemLeft" align="right" valign="top">generic, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fortran-03.html#ga4855936b441ec2242b32cf6e32677fde">flook::luastate::table</a> =&gt; state_tbl_, state_top_tbl_</td></tr>
<tr class="memdesc:ga4855936b441ec2242b32cf6e32677fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation/retrieving tables via either names or from the top of the LUA stack in the current environment.  <a href="#ga4855936b441ec2242b32cf6e32677fde">More...</a><br /></td></tr>
<tr class="separator:ga4855936b441ec2242b32cf6e32677fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf4319c781279cf9301e2053c067e97"><td class="memItemLeft" align="right" valign="top">generic, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fortran-03.html#ga0cf4319c781279cf9301e2053c067e97">flook::luatbl::open</a> =&gt; tbl_open_</td></tr>
<tr class="memdesc:ga0cf4319c781279cf9301e2053c067e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a table in the current table tree.  <a href="#ga0cf4319c781279cf9301e2053c067e97">More...</a><br /></td></tr>
<tr class="separator:ga0cf4319c781279cf9301e2053c067e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec7101a1da6f235244e004b3b338de63"><td class="memItemLeft" align="right" valign="top">generic, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fortran-03.html#gaec7101a1da6f235244e004b3b338de63">flook::luatbl::close</a> =&gt; tbl_close_</td></tr>
<tr class="memdesc:gaec7101a1da6f235244e004b3b338de63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a LUA table.  <a href="#gaec7101a1da6f235244e004b3b338de63">More...</a><br /></td></tr>
<tr class="separator:gaec7101a1da6f235244e004b3b338de63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4af7573a14923e3b23b178ebc125f4f2"><td class="memItemLeft" align="right" valign="top">generic, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fortran-03.html#ga4af7573a14923e3b23b178ebc125f4f2">flook::luatbl::close_tree</a> =&gt; tbl_close_tree_</td></tr>
<tr class="memdesc:ga4af7573a14923e3b23b178ebc125f4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for <code>close(tree=.true.)</code>  <a href="#ga4af7573a14923e3b23b178ebc125f4f2">More...</a><br /></td></tr>
<tr class="separator:ga4af7573a14923e3b23b178ebc125f4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga174dc1a2a46e014f7af49a20c28dde02"><td class="memItemLeft" align="right" valign="top">generic, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fortran-03.html#ga174dc1a2a46e014f7af49a20c28dde02">flook::luatbl::close_open</a> =&gt; tbl_close_open_</td></tr>
<tr class="memdesc:ga174dc1a2a46e014f7af49a20c28dde02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a LUA table, then re-opens it using the provided table name.  <a href="#ga174dc1a2a46e014f7af49a20c28dde02">More...</a><br /></td></tr>
<tr class="separator:ga174dc1a2a46e014f7af49a20c28dde02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae870e783e438e95ee389f1d001d5a9b1"><td class="memItemLeft" align="right" valign="top">generic, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fortran-03.html#gae870e783e438e95ee389f1d001d5a9b1">flook::luatbl::create</a> =&gt; tbl_create_str_, tbl_create_int_, tbl_create_</td></tr>
<tr class="memdesc:gae870e783e438e95ee389f1d001d5a9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open/create a LUA table from a LUA environment.  <a href="#gae870e783e438e95ee389f1d001d5a9b1">More...</a><br /></td></tr>
<tr class="separator:gae870e783e438e95ee389f1d001d5a9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf113998e79dc7d64ef9a84be34185b44"><td class="memItemLeft" align="right" valign="top">generic, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fortran-03.html#gaf113998e79dc7d64ef9a84be34185b44">flook::luatbl::set</a> =&gt; set_s_, set_b_0d_, set_b_1d_, set_b_2d_, set_i_0d_, set_i_1d_, set_i_2d_, set_s_0d_, set_s_1d_, set_s_2d_, set_d_0d_, set_d_1d_, set_d_2d_, open_set_b_1d_, open_set_b_2d_, open_set_i_1d_, open_set_i_2d_, open_set_s_1d_, open_set_s_2d_, open_set_d_1d_, open_set_d_2d_</td></tr>
<tr class="memdesc:gaf113998e79dc7d64ef9a84be34185b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores values in LUA tables.  <a href="#gaf113998e79dc7d64ef9a84be34185b44">More...</a><br /></td></tr>
<tr class="separator:gaf113998e79dc7d64ef9a84be34185b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30ad1bb3b49c0727d72c11798ec54f1e"><td class="memItemLeft" align="right" valign="top">generic, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fortran-03.html#ga30ad1bb3b49c0727d72c11798ec54f1e">flook::luatbl::get</a> =&gt; get_s_, get_s_i_, get_b_0d_, get_b_1d_, get_b_2d_, get_i_0d_, get_i_1d_, get_i_2d_, get_s_0d_, get_s_1d_, get_s_2d_, get_d_0d_, get_d_1d_, get_d_2d_, open_get_b_1d_, open_get_b_2d_, open_get_i_1d_, open_get_i_2d_, open_get_s_1d_, open_get_s_2d_, open_get_d_1d_, open_get_d_2d_</td></tr>
<tr class="memdesc:ga30ad1bb3b49c0727d72c11798ec54f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves values from LUA tables.  <a href="#ga30ad1bb3b49c0727d72c11798ec54f1e">More...</a><br /></td></tr>
<tr class="separator:ga30ad1bb3b49c0727d72c11798ec54f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b41746703940e5470d85d0d8c1d25cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fortran-03.html#ga0b41746703940e5470d85d0d8c1d25cd">flook::len::tbl_len_</a></td></tr>
<tr class="separator:ga0b41746703940e5470d85d0d8c1d25cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This can accomodate more flexibility and allows users to extend data-types etc. </p>
<h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="ga9552df4f66be93a29ba1794435af3c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9552df4f66be93a29ba1794435af3c6c">&sect;&nbsp;</a></span>close() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">generic, public flook::luastate::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the LUA environment for processing. After a call to this you will have to initialize a new LUA instance before you can proceed. </p>

</div>
</div>
<a id="gaec7101a1da6f235244e004b3b338de63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec7101a1da6f235244e004b3b338de63">&sect;&nbsp;</a></span>close() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">generic, public flook::luatbl::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This closes an open table which disables it from interaction using the handle <code>handle</code>.</p>
<p>As the luaTbl class is a <em>following</em> data structure a close will move the table handle to the parent table.</p>
<p>Hence: </p><div class="fragment"><div class="line"><span class="comment">call luaTbl%open(&#39;main.nested.nested&#39;)</span></div><div class="line"><span class="comment">call luaTbl%close()</span></div></div><!-- fragment --><p> will be retain the table handle at <code>main.nested</code>, where as call <code>call luaTblclose(tree = .true.)</code> will close all.</p>
<p>One can supply an integer <code>lvls</code> to specify the number of levels that will be closed. If this number exceeds the number of available nested tables it will be equivalent to <code>tree = .true.</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td><em>optional</em> whether the entire table tree will be closed </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lvls</td><td><em>optional</em> the number of levels that will be closed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga174dc1a2a46e014f7af49a20c28dde02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga174dc1a2a46e014f7af49a20c28dde02">&sect;&nbsp;</a></span>close_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">generic, public flook::luatbl::close_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The following two codes are equivalent, without ambiguity: </p><div class="fragment"><div class="line"><span class="comment">call luaTbl%open(&#39;main.nested&#39;)</span></div><div class="line"><span class="comment">call luaTbl%close()</span></div><div class="line"><span class="comment">call luaTbl%open(&#39;nested_2&#39;)</span></div></div><!-- fragment --><p> and </p><div class="fragment"><div class="line"><span class="comment">call luaTbl%open(&#39;main.nested&#39;)</span></div><div class="line"><span class="comment">call luaTbl%close_open(&#39;nested_2&#39;)</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the table </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lvls</td><td><em>optional</em> keep track of how many levels was actually closed <em>and</em> opened, works as the statement in <a class="el" href="group__fortran-03.html#gaec7101a1da6f235244e004b3b338de63" title="Closes a LUA table. ">close</a> and <a class="el" href="group__fortran-03.html#ga0cf4319c781279cf9301e2053c067e97" title="Opens a table in the current table tree. ">open</a> For instance doing <a class="el" href="group__fortran-03.html#ga174dc1a2a46e014f7af49a20c28dde02" title="Closes a LUA table, then re-opens it using the provided table name. ">close_open</a>('main',lvls=lvls) with <code>lvls=2</code> will return with <code>lvls=1</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4af7573a14923e3b23b178ebc125f4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4af7573a14923e3b23b178ebc125f4f2">&sect;&nbsp;</a></span>close_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">generic, public flook::luatbl::close_tree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>See interface</b>: <a class="el" href="group__fortran-03.html#gaec7101a1da6f235244e004b3b338de63" title="Closes a LUA table. ">close</a>(tree=.true.) </p>

</div>
</div>
<a id="gae870e783e438e95ee389f1d001d5a9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae870e783e438e95ee389f1d001d5a9b1">&sect;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">generic, public flook::luatbl::create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open or creates a LUA table to be post-processed in FORTRAN.</p>
<p>This function returns a table handle #luaTbl to do operations within this table.</p>
<p>If you supply a <code>name</code> it will open the table at that respective name. If the name already has a table it will open that and interact with that table, else it will create a new table and create it in the name. The table names abide to the rules in <a class="el" href="group__fortran-03.html#ga0cf4319c781279cf9301e2053c067e97" title="Opens a table in the current table tree. ">open</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of table, possibly "." separated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a table handle #luaTbl </dd></dl>

</div>
</div>
<a id="ga30ad1bb3b49c0727d72c11798ec54f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30ad1bb3b49c0727d72c11798ec54f1e">&sect;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">generic, public flook::luatbl::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves LUA tables, or entries, to FORTRAN arrays, or variables direct indices and bounds. It will try and read in entries as provided by the FORTRAN array from the equivalent LUA table.</p>
<p>The FORTRAN variable/array passed can be expressed in two different methods:</p><ul>
<li><p class="startli"><b>name</b> based, where an initial <a class="el" href="group__fortran-03.html#ga0cf4319c781279cf9301e2053c067e97" title="Opens a table in the current table tree. ">open</a> is retrieving the table by key before locating array values from that table.</p>
<p class="startli"><b>NOTE</b>: Currently this is only implemented using a character <code>key</code>, hence you cannot use positional entries in this method.</p>
</li>
<li><b>direct</b> based, the currently opened table has the variable/array directly stored.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td><em>optional</em> this constitutes the <b>name</b> based method </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>the array to be retrieved, currently supported dimension and kinds are: scalars, and 1-2 D arrays. The current data types are:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><code>character</code>, (no arrays of this data is allowed)</li>
<li><code>logical</code></li>
<li><code>integer</code></li>
<li><code>real(kind(0.))</code></li>
<li><code>real(kind(0.d0))</code> </li>
</ul>

</div>
</div>
<a id="ga6d7fddb972f9de080fc37a94fc23de13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d7fddb972f9de080fc37a94fc23de13">&sect;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">generic, public flook::luastate::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates new LUA environments by starting LUA.</p>
<p>If the luaState is an already opened LUA environment, it will be closed by an <code>call luaState%close()</code>.</p>
<p>Then, a new LUA environment will be created and will be made available to interact with LUA.</p>
<p>You cannot interact with LUA until you have called <code>luaState%init</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td><em>optional</em> pointer to C-state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0cf4319c781279cf9301e2053c067e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cf4319c781279cf9301e2053c067e97">&sect;&nbsp;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">generic, public flook::luatbl::open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this object already has an open table it will open all named arguments as a nested table.</p>
<p>This openening provides easy access to several nested tables using a "." notation. Hence providing <code>luaTbl%open(name)</code> with value <code>main.nested.nested</code> a table will be created with this equivalent LUA code: </p><div class="fragment"><div class="line">main = { nested = { nested } } }</div></div><!-- fragment --><p>By using the <em>optional</em> keyword <code>luaTbl%open(lvls=lvls)</code> one can retrieve how many levels was opened by <a class="el" href="group__fortran-03.html#ga0cf4319c781279cf9301e2053c067e97" title="Opens a table in the current table tree. ">open</a>. This is handy when you want to close as many nested tables as you have just opened. Hence you can do: </p><div class="fragment"><div class="line">lvls = 0</div><div class="line"><span class="keyword">call </span>luatbl%open(<span class="stringliteral">&quot;main.nested.nested&quot;</span>,lvls = lvls)</div><div class="line"><span class="comment">! do operations</span></div><div class="line"><span class="keyword">call </span>luatbl%close(lvls = lvls)</div></div><!-- fragment --><p> <b>Note</b> the initialization of <code>lvls = 0</code>, this is needed so as to re-use the same operation for nested operation of the table, i.e.: </p><div class="fragment"><div class="line">lvls = 0</div><div class="line"><span class="keyword">call </span>luatbl%open(<span class="stringliteral">&quot;main.nested.nested&quot;</span>,lvls = lvls)</div><div class="line"></div><div class="line"><span class="comment">! do operations at this level</span></div><div class="line"><span class="keyword">call </span>luatbl%open(<span class="stringliteral">&quot;more.nested&quot;</span>,lvls = lvls)</div><div class="line"></div><div class="line"><span class="comment">! do more opeartions at this, deeper, level.</span></div><div class="line"></div><div class="line"><span class="comment">! Finally return to the level at `lvls = 0`</span></div><div class="line"><span class="keyword">call </span>luatbl%close(lvls = lvls)</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the table </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lvls</td><td><em>optional</em> keep track of how many levels was actually opened </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0172f41cd5c88b3aa8a298ebf40faa30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0172f41cd5c88b3aa8a298ebf40faa30">&sect;&nbsp;</a></span>register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">generic, public flook::luastate::register </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows registrering FORTRAN functions as callable functions in LUA.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">function </span>f(L_c) <span class="keyword">result</span>(nret) bind(c)</div><div class="line"> <span class="keywordtype">type</span>(c_ptr), <span class="keywordtype">value</span> : l_c</div><div class="line"> <span class="keywordtype">type</span>(luastate) :: lua</div><div class="line"> <span class="keyword">call </span>lua%init(l_c)</div><div class="line">    <span class="comment">! do operations</span></div><div class="line"> nret = 0</div><div class="line"><span class="keyword">end function</span></div><div class="line"><span class="keyword">subroutine </span>register_fortran_funcs()</div><div class="line"> <span class="keyword">call </span>lua%register(<span class="stringliteral">&#39;fortran_f&#39;</span>,func=f)</div><div class="line"><span class="keyword">end subroutine</span></div></div><!-- fragment --><p> Inside the LUA script you can then call the <code>f</code> code using this: </p><div class="fragment"><div class="line">fortran_f()</div></div><!-- fragment --><p>Some notes on the function declaration. The returned result <code>nret</code> is an integer count of how many objects on the stack you wish to return. For instance, if you create a single table in the <code>f</code> function <code>nret = 1</code> and the LUA call had to be <code>tbl = fortran_f()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the exposed function name in LUA </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>the FORTRAN function passed by pointer to be attached to the LUA environment by calling <code>name</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa9043137552c934a0ced08b21d08195f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9043137552c934a0ced08b21d08195f">&sect;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">generic, public flook::luastate::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run LUA code from either direct interaction, or by running a file.</p>
<p>The default mode is that it will run the file given as the argument (<code>file</code>-keyword).</p>
<p>By passing a <code>code = character(*)</code> by named argument one can execute specific code.</p>
<p>A few examples:</p>
<div class="fragment"><div class="line"><span class="keywordtype">type</span>(luastate) :: lua</div><div class="line"><span class="keyword">call </span>lua%init()</div><div class="line"></div><div class="line"><span class="comment">! Call initialization file called &#39;init_file.lua&#39;</span></div><div class="line"><span class="keyword">call </span>lua%run( <span class="stringliteral">&#39;init_file.lua&#39;</span> )</div><div class="line"></div><div class="line"><span class="comment">! Call lua code</span></div><div class="line"><span class="keyword">call </span>lua%run( code = <span class="stringliteral">&#39;table = {}&#39;</span> )</div><div class="line"><span class="keyword">call </span>lua%run( code = <span class="stringliteral">&#39;table.item = 1.&#39;</span> )</div><div class="line"></div><div class="line"><span class="keyword">call </span>lua%close()</div></div><!-- fragment --><p>The equivalent LUA code would be: </p><div class="fragment"><div class="line">dofile(&quot;init_file.lua&quot;)</div><div class="line">table = {}</div><div class="line">tabel.item = 1.</div></div><!-- fragment --><p>To create an interactive LUA enviroment in FORTRAN you do a loop </p><div class="fragment"><div class="line"><span class="keywordtype">type</span>(luastate) :: lua</div><div class="line"><span class="keywordtype">character(len=512)</span> :: line</div><div class="line"><span class="keywordflow">do</span> </div><div class="line">  <span class="comment">! Read line</span></div><div class="line">  <span class="keyword">read</span>(*,*) line</div><div class="line">  <span class="keyword">call </span>lua%run( code = line )</div><div class="line"><span class="keywordflow">end do</span></div><div class="line"><span class="keyword">call </span>lua%close()</div></div><!-- fragment --><p> Note that running LUA like the above example may require additional work as each line segment has to be completed. Hence executing several lines in a disconnected way is not as easy.</p>
<p>If both <code>file</code> and <code>code</code> arguments has been given, first the file with be executed, then the code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td><em>optional</em> executes a <code>dofile(file)</code> in LUA </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td><em>optional</em> executes <code>code</code> in LUA </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td><em>optional</em> error ID from LUA (non-zero for error) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message</td><td><em>optional</em> error message from LUA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf113998e79dc7d64ef9a84be34185b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf113998e79dc7d64ef9a84be34185b44">&sect;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">generic, public flook::luatbl::set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores FORTRAN arrays in LUA tables by direct indices and bounds. It preserves any bounds found by the passed array and expresses that in the equivalent LUA table.</p>
<p>The LUA table passed can be expressed in two different methods:</p><ul>
<li><p class="startli"><b>name</b> based, where an initial <a class="el" href="group__fortran-03.html#ga0cf4319c781279cf9301e2053c067e97" title="Opens a table in the current table tree. ">open</a> is called to create, or retrieve a table by key before storing the array in that table.</p>
<p class="startli"><b>NOTE</b>: Currently this is only implemented using a character <code>key</code>, hence you cannot use positional entries in this method.</p>
</li>
<li><b>direct</b> based, the currently opened table has been created by the user and subsequent storage is directly in this table. This is handy if you want to assign other information subsequently.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td><em>optional</em> this constitutes the <b>name</b> based method </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>the array to be stored, currently supported dimension and kinds are: scalars, and 1-2 D arrays. The current data types are:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><code>character</code>, (no arrays of this data is allowed)</li>
<li><code>logical</code></li>
<li><code>integer</code></li>
<li><code>real(kind(0.))</code></li>
<li><code>real(kind(0.d0))</code> </li>
</ul>

</div>
</div>
<a id="ga4855936b441ec2242b32cf6e32677fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4855936b441ec2242b32cf6e32677fde">&sect;&nbsp;</a></span>table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">generic, public flook::luastate::table </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a table in the main environment by names (creates a new table) or retrieve a table from the stack (via function calls).</p>
<p>The table name has the same format as #open.</p>
<p>See #luaTbl for specifications of the return value.</p>
<p>As an example: </p><div class="fragment"><div class="line"><span class="keywordtype">type</span>(luastate) :: lua</div><div class="line"><span class="keywordtype">type</span>(luatbl) :: tbl</div><div class="line"></div><div class="line"><span class="comment">! Create new lua env</span></div><div class="line"><span class="keyword">call </span>lua%init()</div><div class="line"></div><div class="line"><span class="comment">! Create a table as a variable</span></div><div class="line">tbl = lua%table(<span class="stringliteral">&#39;main&#39;</span>)</div><div class="line"><span class="comment">! Close it again</span></div><div class="line"></div><div class="line"><span class="comment">! Create a nested table inside `main`</span></div><div class="line"><span class="keyword">call </span>tbl%open(<span class="stringliteral">&#39;main.nest_one.nest_two&#39;</span>)</div><div class="line"></div><div class="line"><span class="comment">! Close the entire tree</span></div><div class="line"><span class="keyword">call </span>tbl%close_tree()</div><div class="line"></div><div class="line"><span class="comment">! You can also do everything at one time</span></div><div class="line">tbl = lua%table(<span class="stringliteral">&#39;new.nest_one.nest_two&#39;</span>)</div></div><!-- fragment --><p> The equivalent LUA code would look like: </p><div class="fragment"><div class="line">main = {}</div><div class="line">main.nest_one = {}</div><div class="line">main.nest_one.nest_two = {}</div><div class="line">-- The later table creation can be expressed in compact form:</div><div class="line">new = { nest_one = { nest_two = {} } }</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td><em>optional</em> name of table to open, can be "." delimited as luaTbl::open </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>luaTbl the table object to post-process </dd></dl>

</div>
</div>
<a id="ga0b41746703940e5470d85d0d8c1d25cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b41746703940e5470d85d0d8c1d25cd">&sect;&nbsp;</a></span>tbl_len_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flook::len::tbl_len_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 27 2017 20:52:17 for flook by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
